# 关于数组和指针的C语言知识

[TOC]



## 前言:

在开发基于ESP8266_RTOS_SDK2.0.0开发esp8266的过程中，很多时候都要对字符串,指针,数组进行处理，在此过程中遇到了一些小问题，都是因为没有透彻理解指针和数组，本文结合ｃ专家编程和8266项目．

## 指针

### 指针定义

#### 指针:保存数据的**地址**

```
/*********************************************************************
*申请一个指向int类型变量的地址,在定义时未初始化(未赋值),所以这个指针保存的地址没有分配空间,这个指针是没*有意义的,也就是野指针,而且这个指针指向哪是随机的,如果指向了系统使用的内存,而用户不小心操作了这个指针,会*使系统奔溃
*
*指针变量int_ptr始终位于一个地址,但是这个指针可以指向任意的int型变量,这些int变量可以存储
*不同的值.
*
**********************************************************************/

int* int_ptr; 
//申请一个char型指针
char* char_ptr;
...

```

:happy: **感悟**: 指针就是一个保存变量地址的变量,定义指针的时候如果不进行赋值的话,**最好给它赋值为0**:

```
int* int_ptr = 0;//在一些系统中0地址就是NULL地址(注意不是0数值)
//或者
int* int_ptr = NULL;
//ANSI C 中NULL的宏定义
#define NULL (void*)0
```

#### 指针为什么要区分指针类型

使用sizeof查看指针的大小,我们会发现在**32位**机器上int*int_ptr和char * char_ptr的大小都是4字节.因为32位机里所有的内存地址都是32位长,既然如此为什么还要区分指针类型呢?

原因是指针所指向的变量是不同的类型,当我们执行int_ptr++时,指针会指向下一个sizeof(int)的内存区域,但是char_ptr++,会指向下一个sizeof(char)大小的内存区域,int在32位机中占用4个字节空间,char占用一个字节的空间,

同样的当我们使用*char_ptr取出指针所指向的变量保存的值时,会取出一个字节的数据,而* * int_ptr,会取出四个字节的int数据.

:happy:**感悟**:当你通过指针来访问指针所指向的那块内存区时,指针的类型决定了编译器会把那块内存区了的内容当做什么来看待.

#### 指针的安全问题

```int* int_ptr; 
int* int_ptr; 
//申请一个char型指针
char* char_ptr = 'a';
int_ptr = (int*)char_ptr
*int_ptr = 1123;
//最后一条语句不仅会改变char_ptr所指向的一个字节的数据,还会改变与之相邻的3个字节的数据,如果这三个
字节中保存了重要的数据,会造成奔溃性错误.
```

:happy:**感悟**:在指针进行强制类型转换时:ptr1 = (TYPE*)ptr2,如果ptr1的数据类型大于ptr2,那么使用ptr1来访问ptr2指向的存储区是不安全的,反之则是安全的.

:happy:**感悟**: ***程序员一定要明确自己的指针指向了什么***



